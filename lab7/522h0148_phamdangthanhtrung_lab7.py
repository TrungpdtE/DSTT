# -*- coding: utf-8 -*-
"""522H0148_PhamDangThanhTrung_lab7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VQzc9K-7IfjNqNM21WEc91EphcZa-S1p
"""

import numpy as np
#caua


##add colum np.colum_stack

a=[1,2,3,4]
v1=np.array(a)
b=[-1,0,1,3]
v2=np.array(b)
c=[2,-1,3,6]
v3=np.array(c)
d=[3,-6,17,11]
w=np.array(d)
print(v1,v2,v3,w)
A=np.array([v1,v2,v3])
print(A)
A=np.transpose(A)
print("A=",A)
Aw=np.transpose(np.array([v1,v2,v3,w]))
print("Aw=",Aw)
rankA=np.linalg.matrix_rank(A)
rankAw=np.linalg.matrix_rank(Aw)
if(rankA==rankAw):
  print("cau a: w is linear combuation of v1,v2,v3")
else:
  print("cau a: w is not linear combuation of v1,v2,v3")
#caub
a=[1,1,2,2]
v1=np.array(a)
b=[2,3,5,6]
v2=np.array(b)
c=[2,-1,3,6]
v3=np.array(c)
d=[0,5,3,0]
w=np.array(d)
print(v1,v2,v3,w)
A=np.array([v1,v2,v3])
print(A)
A=np.transpose(A)
print("A=",A)
Aw=np.transpose(np.array([v1,v2,v3,w]))
print("Aw=",Aw)
rankA=np.linalg.matrix_rank(A)
rankAw=np.linalg.matrix_rank(Aw)
if(rankA==rankAw):
  print("cau b: w is linear combuation of v1,v2,v3")
else:
  print("cau b: w is not linear combuation of v1,v2,v3")
#cauc
a=[1,1,2,2]
v1=np.array(a)
b=[2,3,5,6]
v2=np.array(b)
c=[2,-1,3,6]
v3=np.array(c)
d=[-1,6,1,-4]
w=np.array(d)
print(v1,v2,v3,w)
A=np.array([v1,v2,v3])
print(A)
A=np.transpose(A)
print("A=",A)
Aw=np.transpose(np.array([v1,v2,v3,w]))
print("Aw=",Aw)
rankA=np.linalg.matrix_rank(A)
rankAw=np.linalg.matrix_rank(Aw)
if(rankA==rankAw):
  print("cau c: w is linear combuation of v1,v2,v3")
else:
  print("cau c: w is not linear combuation of v1,v2,v3")
#caud
a=[1,2,3,4]
v1=np.array(a)
b=[-1,0,1,3]
v2=np.array(b)
c=[0,5,-6,8]
v3=np.array(c)
c1=[1,15,-12,8]
v4=np.array(c1)
d=[0,-6,17,11]
w=np.array(d)
print(v1,v2,v3,v4,w)
A=np.array([v1,v2,v3,v4])
print(A)
A=np.transpose(A)
print("A=",A)
Aw=np.transpose(np.array([v1,v2,v3,v4,w]))
print("Aw=",Aw)
rankA=np.linalg.matrix_rank(A)
rankAw=np.linalg.matrix_rank(Aw)
if(rankA==rankAw):
  print("cau d: w is linear combuation of v1,v2,v3,v4")
else:
  print("cau d: w is not linear combuation of v1,v2,v3,v4")

#cau2
#caua
A2=np.transpose(np.array([[1, -2, 0], [0, -4, 1], [1, -1, 1] ]))
print(A2)
rankA2=np.linalg.matrix_rank(A2)
print(A2)
if(rankA2==A2.shape[1]):
  print("cau a: Are linearly independent")
else:
  print("cau a: Are NOT linearly independent")
  ###dung ham cho nhanh
def check_linear_independent(w):
  rankw=np.linalg.matrix_rank(w)
  if(rankw==w.shape[1]):
     print("Are linearly independent")
  else:
    print("Are NOT linearly independent")

  #caub
b1=np.array([1,0,2])
b2=np.array([0,1,4])
b3=np.array([2,-2,4])

B=np.transpose(np.array([b1,b2,b3]))
rank_B=np.linalg.matrix_rank(B)
print(rank_B)

if(rank_B==B.shape[0]):
  print("cau B: is linear independent")
else:
  print("cau B: is not linear independent")
#d

D2=np.transpose(np.array([[0, 0, 1, 2, 3],[0, 0, 2, 3, 1],[1, 2, 3, 4, 5],[2, 1, 0, 0, 0],[-1, -3, -5, 0, 0]]))
print(check_linear_independent(D2))

#cau3
import numpy as np
import sympy as sp
C=np.array([[1,0,2,3],[4,-1,0,2],[0,-1,-8,-10]])
#a
res=sp.Matrix(C).rref()
basic_C=C[:,list(res[1])]
print("C basis for the column space of C=",basic_C)
#b
C_b=np.transpose(C)
res_b=sp.Matrix(C_b).rref()
basic_Cb=C_b[:,list(res[1])]
print("C basis for the row space of C=",basic_Cb)

#cau4
A2=np.array([[1,0,2,3],[4,-1,0,2],[0,-1,-8,-10]])
res=sp.Matrix(A2).nullspace()
basic_nullspace=np.array(res[0])
for i in range(1,len(res)):
  basic_nullspace=np.hstack((basic_nullspace,np.array(res[i])))
print(basic_nullspace)
print("v1=",np.matmul(A2,basic_nullspace[:,0]))
print("v2=",np.matmul(A2,basic_nullspace[:,1]))

#cau5
import numpy as np
A=np.array([
    [7,6,-4,1],
    [-5,-1,0,-2],
    [9,-11,7,-3],
    [19,-9,7,1] 
])

w=np.array([1,1,-1,3]).T
print("A*w",np.matmul(A,w))
if(np.allclose(np.matmul(A,w),[0,0,0,0])):
  print("w is in the null space of matrix A")
else:
  print("w is not in the null space of matrix A")

#cau6
import numpy as np
u1=np.array([3,1,1])
u2=np.array([-1,2,1])
u3=np.array([-1/2,-2,7/2])
U=np.array([u1,u2,u3])
print(U)
def check_orthogonal_set(U):
  for i in range(U.shape[0]):
    for j in range(U.shape[1]):
      if i!=j:
        if np.matmul(U[i],U[j])!=0: #tichvohuong2vecto
          print("is NOT an arthogonal set")
          return
  print("is an orthogonal set")

import numpy as np
import sympy as sp

A = np.array([[1, 0, 2], [0, 1, 4], [2, -2, -4]])

rref, pivots = sp.Matrix(A).rref()
dim = len(pivots)

basis = A[:, pivots]

print("Chiều của không gian con sinh là:", dim)
print("Cơ sở của không gian con sinh là:\n", basis)

import numpy as np
A = np.array([[1/(i+j-1) for j in range(1,6)] for i in range(1,6)])
null_space = np.linalg.pinv(A).ravel()[A.shape[0]:]
print("Một cơ sở cho null space của ma trận Hilbert là:")
print(null_space)

#cau b
import scipy.special

A = np.array([[scipy.special.comb(i+j-2, i-1) for j in range(1,6)] for i in range(1,6)])

null_space = np.linalg.pinv(A).ravel()[A.shape[0]:]

print("Một cơ sở cho null space của ma trận Pascal là:")
print(null_space)

#cau c
A = np.array([[16, 23, 17, 4, 10],
              [5, 7, 24, 18, 15],
              [11, 12, 6, 25, 19],
              [22, 20, 14, 8, 1],
              [3, 9, 21, 13, 2]])
null_space = np.linalg.pinv(A).ravel()[A.shape[0]:]
print("Một cơ sở cho null space của ma trận Magic là:")
print(null_space)

import numpy as np
u1=np.array([3,1,1])
u2=np.array([-1,2,1])
u3=np.array([-1/2,-2,7/2])
U=np.array([u1,u2,u3])
print(U)

def check(U):
  for i in range(U.shape[0]):
    for j in range(U.shape[1]):
      if(i!=j):
        if(np.matmul(U[i],U[j])!=0):
          return False
  return True

if check(U):
  print("Orthogonal set")
else:
  print("Not orthogonal set")

import numpy as np
y=np.array([7,6])
u=np.array([4,2])

def orthogonal_project(y,u):
  numer=np.dot(y,u)
  denom=np.dot(u,u)
  result=(numer/denom)*u
  return result
projection=orthogonal_project(y,u)
print(projection)

import numpy as np

def has_orthonormal_columns(matrix):
    num_rows, num_cols = matrix.shape
    product = np.dot(matrix.T, matrix)
    identity = np.identity(num_cols)
    return np.allclose(product, identity)

A = np.array([[1, 0], [0, 1]])
result = has_orthonormal_columns(A)
print(result)

import numpy as np

v1 = [-10, 2, -6, 16, 2]
v2 = [13, 1, 3, -16, 1]

v1_unit = v1 / np.linalg.norm(v1)
v2_orth = v2 - np.dot(v2, v1_unit) * v1_unit
v2_unit = v2_orth / np.linalg.norm(v2_orth)

v3 = [7, -5, 13, -2, -5]
v3_orth = v3 - np.dot(v3, v1_unit) * v1_unit - np.dot(v3, v2_unit) * v2_unit
v3_unit = v3_orth / np.linalg.norm(v3_orth)

v4 = [-11, 3, -3, 5, -7]
v4_orth = v4 - np.dot(v4, v1_unit) * v1_unit - np.dot(v4, v2_unit) * v2_unit - np.dot(v4, v3_unit) * v3_unit 
v4_unit = v4_orth / np.linalg.norm(v4_orth)  

Q = np.column_stack((v1_unit, v2_unit, v3_unit, v4_unit))  
print(Q)

#cau1
import numpy as np
import matplotlib.pyplot as plt


X = np.array([1, 3, 6, 7])
Y = np.array([7, 2, 1, 2])


coefficients = np.polyfit(X, Y, 2)
a, b, c = coefficients


plt.plot(X, Y, 'ro', label='Data')  
x_values = np.linspace(0, 10, 100)  
y_values = a * x_values**2 + b * x_values + c  
plt.plot(x_values, y_values, 'b-', label='Approximation')  
plt.xlabel('X')
plt.ylabel('Y')
plt.legend()


x_test = 10
y_test = a * x_test**2 + b * x_test + c
plt.plot(x_test, y_test, 'go', label='Estimated Point (x=10)')
plt.annotate(f'({x_test}, {y_test})', (x_test, y_test), textcoords="offset points", xytext=(0,10), ha='center')

plt.title('Approximation of y = ax^2 + bx + c')
plt.show()

#cau2
import sympy as sp
C=np.array([[-2,2,6,0],[0,6,7,5],[1,5,4,5]])
#a
res=sp.Matrix(C).rref()
basic_C=C[:,list(res[1])]
print("A basis for the column space of C=\n",basic_C)

#b
C_b=np.transpose(C)
res_b=sp.Matrix(C_b).rref()
basic_Cb=C_b[:,list(res[1])]
print("A basis for the row space of C=\n",basic_Cb)

#cau3
import numpy as np
A= np.array([[3,4,5],
            [1,3,1],
            [1,1,2]])
E= np.array([[73,134,260,190,183,167],
            [27,41,90,62,63,55],
            [25,49,92,68,64,60]])
A_tru1 = np.linalg.inv(A)
D = np.matmul(A_tru1,E)
mess = ""
print(D)
for i in range(len(D[0])):
    for j in range(len(D)):
        if(round(D[j][i])==30):
            mess += " "
        else:
            mess += chr(round(D[j][i]+61))
print("Ket qua la : ",mess)